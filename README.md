# 🙋‍♂ Chap02_객체 지향
## 📚 절차 지향과 객체 지향
### 🔖 절차 지향
- 절차 지향(Procedural Oriented) 프로그래밍은 프로시저(Procedure)로 프로그램을 구성하는 기법
- 절차 지향에서 절차는 오번역. procedural은 '절차'라는 뜻보다 프로시저를 뜻함 
  - 프로시저란 -> 예) 오퍼레이션, 메서드, 함수 등
      - 프로그래밍에서, 프로시저는 루틴이나, 서브루틴 및 함수와 같은 뜻이다. 하나의 프로시저는 특정 작업을 수행하기 위한 프로그램의 일부이다.
      - 일반적인 의미의 프로시저란, 어떤 행동을 수행하기 위한 일련의 작업 순서를 말한다.  
    
![1](https://user-images.githubusercontent.com/95393311/151661987-61a9f60a-beb2-4a98-ba28-e0d05fd7e8b9.JPG)
<절차 지향은 데이터를 중심으로 한 프로시저로 구성된다>
- 문제점
  - 데이터 타입이나 의미를 변경할 때, 함께 수정해야 하는 프로시저가 증가
  - 같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생
  
### 🔖 객체 지향
- 데이터 및 데이터와 관련된 프로시저를 객체(Object)라고 불리는 단위로 묶음
 ![2](https://user-images.githubusercontent.com/95393311/151662239-a909d10a-d673-476e-8eb7-5f021e30f6dd.JPG)
- 객체 지향 프로그래밍은 자신만의 데이터와 프로시저를 가진 객체들이 서로 연결 및 협력하는 프로그래밍
- 절차 지향 프로그래밍과 다르게 객체 별로 데이터와 프로시저를 정의해야 하기 때문에 프로그램의 규모가 작을 때 더 복잡한 구조를 가짐
- 하지만 다른 객체에 영향을 주지 않고 각 개체 안에서만 변화가 이뤄져, 요구 사항을 변경하는 등 유연성이 더 높다

## 📚 객체
### 🔖 객체의 핵심은 기능을 제공하는 것
- 객체를 정의할 때는 데이터(프로퍼티, 상태)가 중심이 아니라 기능(메서드)을 중심으로!
- 프로퍼티 또는 상태는 기능을 만들고 나서 어떤 데이터가 필요하겠다라고 생각할 때 만드는 것
- <객체 지향의 사실과 오해(통칭 토끼책) 중>
  - 앨리스의 이야기 중, "앨리스가 버섯을 먹고 키가 커져서 문을 통과할 수 있었다" 라는 스토리가 있다
    - "버섯을 먹다<기능>"를 통해 "키<상태>가 커졌다<변화>". 즉, 버섯을 먹다라는 기능을 통해 키<상태>가 필요하게 됨
### 🔖 인터페이스와 클래스
- 여기서 인터페이스는 자바/코틀린에서 나오는 인터페이스 기능이 아닌 객체가 제공하는 모든 오퍼레이션의 집합
- 서로 다른 인터페이스들을 식별하기 위해 사용되는 명칭이 '타입'
- 인터페이스는 객체가 제공하는 기능의 명세서이며, 실제로 기능은 없다
- 이런 인터페이스에서 실제로 기능을 구현 및 정의한 것이 클래스
### 🔖 메시지
- 객체 지향은 앞서 설명한 대로, 여러 객체의 협력을 통해 만들어지는 네트워크로 구성됨
- 한 객체가 자신의 기능을 구현하기 위해서 다른 객체의 기능이 필요할 경우, 해당 개체에게 해당 기능을 실행해 달라고 '요청'해야 하며, 이 과정을 '메세지'라고 함
- 따라서 객체는 메시지를 송신하는(요청하는) 객체와 메시지를 수신받는(요청을 수신받는) 객체로 나뉜다
- <토끼책>
  - 메시지를 송신하는 객체는 메시지를 수신받는 객체가 해당 기능을 반드시 실행할 거라는 믿음이 있다. 따라서 메시지를 수신받는 객체는 요청받은 기능을 반드시할 '책임'이 있음
- 자바/코틀린에서는 메서를 호출하는 것이 대표적인 메시지를 보내는 것

## 📚 객체의 책임과 크기
- 객체가 제공하는 기능 = 객체가 가진 책임
- 객체가 갖는 책임(=기능)을 결정하는 것이 바로 객체 지향 설계의 출발점
- 그러기 위해서는 앞서 설명한 대로, 데이터를 먼저 생각하지 말고 어떤 기능이 필요할지 먼저 생각하자
- 한 객체가 책임이 많을수록 절차 지향적으로 변함
- 객체가 가진 책임이 작을수록 유연성이 높아짐
- 객체의 크기와 관련된 설계 원칙은 '단일 책임의 원칙(SRP)'
- 결론 - 하나의 객체에는 하나의 책임만 있도록 설계/할당하자
- 그럼 큰 기능은? > 여러 객체를 조립하자
## 📚 의존
- 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출하거나 파라미터로 전달받을 때, 객체가 다른 객체에 의존한다고 표현
- 의존성을 가진 객체들은 의존받고 있는 객체가 수정되면 의존하고 있는 객체도 수정해야 하며, 의존하고 있는 객체를 또다른 객체에게 의존하고 있다면 해당 객체도 수정해야하는 순환 의존이 발생함
- 이를 해소하기 위해 객체 지향 설계 원칙 중 '의존 역전 원칙'이 있다

## 📚 캡슐화
- 캡슐화란 객체가 내부적으로 어떻게 기능을 구현하는지를 감추는 것
- 따라서, 수정이 있더라도 그 여파가 다른 객체에 미치치 않도록 최소화함
- 캡슐화를 통해 코드의 유연성을 높일 수 있다
  - 간단한 예시로 리모콘을 통해 TV를 켤 때, 전원버튼을 누르기만 하면 TV가 켜진다. 여기서 우리는 전원 버튼을 눌렀을 때, 리모콘 내부에서 어떤 방식으로 작동되는지 알고 싶지도 않고 알아야할 필요도 없다. 우리게에 필요한 건 "버튼을 누름 > 전원이 켜/꺼짐"
  - 이후에 전원버튼을 동작시키는 내부 구조가 변경되더라도 우리가 전원 버튼을 눌렀을 때, TV가 켜/꺼지는 기능은 변하지 않는다.
- 캡슐화를 위한 두 개의 규칙.
  - Tell, Don't Ask
    - <토끼책>
      - 메시지를 송신할 때는 What(무엇을)만을 요청하고 How(어떻게)는 요청하지 말자
      - 앞서 말한 예시에서, 우리는 리모컨에게 'TV를(what) 켜' 라고만 요청해야 한다. 만약 리모컨에게 '삐-이 소리가 3초 이상 나면서 3초간 발광하면서(how) TV켜' 라고 요청하면 안된다. 이는 이후에 추가 요구 사항이 있으면 코드를 수정하기 힘들어 유연성이 떨어진다.
      - 따라서 책임(기능) 및 메시지를 정할 때도 어느 정도 추상화가 필요하다
  - 데미테르의 법칙
    - 메서드에서 생성한 객체의 메서드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드를 참조하는 객체의 메서드만 호출
      - 결론 
        - 자신의 객체 안에 다른 객체를 생성하고 해당 객체의 메서드만을 사용하자.
        - 즉, 자신의 객체 안에서 생성한 객체가 또다른 객체를 생성하고 사용하고 있다면 해당 객체의 메서드를 사용하지 말자(왜냐? 그 객체가 수정된다면 결국 내가 영향을 받는다)

## 📚 객체 지향 설계 과정
- 객체 지향의 설계란 다음의 작업의 반복
  1. 제공해야할 기능 정의하고 알맞은 객체에 할당
     1. 기능을 정의했으면 그에 따른 데이터 추가
     2. 기능은 최대한 캡슐화
  2. 객체 간의 메시지 송신 및 수신을 정하여 협력을 이끌어 냄
  3. 과정 1, 2를 반복
- 만약 한 객체에 여러 책임이 있다면 분리하자 
- 설계는 처음부터 완성되지 않고 설계 - 구현 - 설계 - 구현 등 반복을 통해 점진적으로 완성된다. 따라서 처음부터 완벽하게 설계할 필요없으며, 유연한 구조를 고려하자.