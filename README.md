# 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴

## Chapter2. 객체 지향

---

## 1. 절차지향과 객체지향
- 절차지향이라는 용어 때문에 객체지향은 절차적이지 않다고 생각할 수 있지만, 객체지향도 마찬가지로 절차적으로 프로그램을 수행한다. 
- 단지 절차지향은 프로그램의 순서를 먼저 결정하고 데이터와 함수를 설계하는 반면, 객체지향은 데이터와 프로시저를 하나로 묶는 객체라는 단위를 먼저 설계한 후 프로그램의 순서를 결정한다는 차이가 있다.
- [잘 정리된 글](https://m.blog.naver.com/atalanta16/220249264429)

### 절차지향
- 프로시저(Procedure) 단위로 프로그램이 구성되며, 데이터를 중심으로 한 패러다임
- 여러 프로시저가 동일한 데이터를 공유

- **장점**
    
    1. 구현이 비교적 쉬움
        - 데이터를 중심으로 하기때문에 함수를 데이터에 맞게 구현함
    2. 규모가 크지 않은 프로젝트에서 유용함

- **단점**
    
    1. 요구사항이 변경되면 수정되어야 할 프로시저가 증가함
        - 프로시저가 수정되면 동일한 데이터를 사용하는 모든 프로시저가 수정되어야 함
    2. 같은 데이터를 프로시저들이 서로 다른 의미로 사용될 수 있음
        - 서로 다른 기능을 하는 프로시저들이 같은 변수를 사용할 위험성이 있음
    3. 프로그램의 규모가 커질수록 코드의 수정과 기능의 추가에 대한 비용이 큼
    
### 객체지향
- 데이터 및 데이터와 관련된 프로시저를 객체(Object) 단위로 구성하고 관리하는 패러다임
- 자신의 객체 데이터에만 접근할 수 있음

- **장점**
    
    1. 요구사항이 변경되더라도 해당 객체만 수정하면 되므로 유지보수가 쉬움
    2. 유지보수가 쉽기 때문에 대형 프로젝트에서 유용함
    3. 재사용성이 높음 (상속, 다형성 등)

- **단점**

    1. 객체 지향적으로 설계하고 개발하는데 비용이 큼
        - 객체끼리의 관계와 재사용성을 높이기 위한 상속, 다형성 등의 고민
    2. 실행 속도가 절차지향에 비해 느림
        - 객체를 할당하고 접근하는 과정 등에 대한 CPU의 연산
    3. 메모리 양의 증가
        - 변수가 아닌 객체 단위로 구성되기 때문

---

## 2. 객체(Object)
- 객체는 클래스의 인스턴스이며, 메모리에 할당되기 전까지 객체는 존재하지 않는다.
- **객체는 데이터와 그 데이터를 조작하는 프로시저(오퍼레이션, 메서드, 함수)로 구성**된다.
    - 오퍼레이션(Operation) : 보통 객체가 제공하는 기능을 오퍼레이션(Operation)이라고 부른다.
- 객체가 어떤 데이터를 내부에 가지고 있고, 어떻게 구현되어있는지에 대한것은 사용하는 입장에서는 알 필요가 없다. 

> (TMI) C언어에도 객체(Object)라는 개념이 있다고 한다. [참고1](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=han95173&logNo=220765393422) [참고2](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf)<br><br>
>3.15<br>
>1 object<br>
>region of data storage in the execution environment, the contents of which can represent values.

### 인터페이스와 클래스
- 오퍼레이션의 사용법은 일반적으로 세 개로 구성되며 이를 `시그니처(Signature)`라고 부른다.
    1. 기능 식별 이름
    2. 파라미터 및 파라미터 타입
    3. 기능 실행 결과 값
- 객체가 제공하는 모든 오퍼레이션 집합을 객체의 `인터페이스(interface)`라고 부른다.
    - 객체를 사용하기 위한 명세서나 규칙, 프로토타입
- 오퍼레이션을 구현하는데 필요한 구현이 포함된 것을 `클래스(class)`라고 부른다.
- 위에서 언급한 `인터페이스`와 `클래스`는 자바에서 사용하는 것을 말한것이 아니라 객체 지향에서 사용하는 개념상의 `인터페이스`와 `클래스`를 말한다.

### 메시지
- 객체는 메시지를 통해 서로 통신한다. 즉, A객체에서 B객체의 오퍼레이션 실행을 요청하는 것을 `메시지를 보낸다`라고 한다.
- `메소드를 호출한다`라고 부르기도 한다.
- 이런 개념을 이용한 `메시징 패턴(Messaging Pattern)`도 존재한다.
    - 이 메시징 패턴은 다른 디자인 패턴을 구현하는데 사용된다.
- [잘 정리된 글](https://panonit.com/blog/overview-message-passing-object-oriented-programming)

---

## 3. 객체의 책임과 크기
- 객체는 자신만의 책임을 가지고 있다. 책임이라는 것은 하나의 객체는 하나의 일만 한다는 것인데, 한 객체에 기능이 많아지게 되면 결국 데이터를 공유해서 사용하게 되고 이는 결국 절차 지향적인 구조를 갖게 된다.
- 한 객체가 여러가지 일을 하게 되면 기능을 변경하는 것이 어렵게 된다.
- 이러한 원칙을 `객체 지향 설계 원칙 5가지 (SOLID)`중 하나인 `단일 책임 원칙(SRP)`라고 한다.

## 4. 의존
- 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 **의존** 한다고 표현한다.
    - 객체를 파라미터로 전달받는 경우에도 포함된다.
- 다른 타입에 의존한다는 것은 의존하는 타입이 변경될 때 나 자신도 같이 변경될 가능성이 높다.
- `A클래스`가 `B클래스`를 의존하고, `B클래스`는 `C클래스`를 의존한다고 하면 아래와 같은 그림이 그려진다.
    - `[A클래스] ---> [B클래스] ---> [C클래스]`
    - 위와같이 그려질 경우 `C클래스`가 변경되면 `B클래스`가 변경되고, `B클래스`가 변경되면 `A클래스`가 변경될 수 있다.
    - 결국 `A클래스`가 변경되면 다시 `C클래스`에도 영향을 줄 수 있는데, 이를 `순환 의존`이라고 한다.
        - `순환 의존`은 객체 지향 설계 원칙 중 `의존 역전의 원칙(DIP)`를 이용해 연결고리를 끊을 수 있다.
            - `의존 역전의 원칙(DIP)`는 `추상화(인터페이스 등)`에 의존해야하며 `구체화`에 의존하면 안된다는 뜻으로, 클래스에 의존하게 되면 위와 같이 `순환 참조`문제나 클래스의 변경이 발생했을 때 유연하게 대응하기가 어렵다.
            - 추상화(인터페이스)에 의존하게 되면 클래스의 변경이 발생하거나 동작은 동일하지만 아예 다른 기능을 사용해야 할 때에도 단순히 코드의 전체를 바꿀 필요없이 클래스만 교체해서 사용할 수 있다.

## 5. 캡슐화
- 객체 지향에서의 캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것으로, 메소드 내부의 로직이 변경되더라도 그 메소드를 사용하는 입장에서는 어떤 변화가 생겼고 어떤 변수들을 사용했으며, 어떤 기능이 추가됐는지에 대해서 알 필요가 없어 내부 구현 변경에 유연함을 주는 기법이다.
- 데메테르(디미터, 디메테르)의 법칙
    - 메서드에서 생성한 객체의 메서드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출
    - `member.getDate().getTime()` 과 같은 코드는 법칙을 위반한 코드이다.
    - 즉, 여러 개의 `.(dot)`을 사용해서는 안되며, 참조하는 객체가 어떤 자료들을 가지고 있는지에 대해서는 몰라야 한다.
    - 데메테르의 법칙을 적용하면 위 코드는 `member.XXXX()`와 같은 메서드로 같은 기능을 할 수 있게 구현해야 한다.

- 절차 지향에서의 캡슐화
    - 책에서는 절차 지향 방식 코드 설명에서 절차 지향으로는 캡슐화가 불가능하다고 말하는 것 처럼 느껴질 수 있는데, 실제로 C언어에서는 캡슐화 및 상속, 다형성 등을 모두 구현할 수는 있지만 구현하기 어렵고 복잡하다는 단점이 있다. [참고1](https://www.kernelpanic.kr/12?category=874323) [참고2](https://velog.io/@hamdoe/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-5.-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D) [참고3](https://mongsil-jeong.tistory.com/22)

## 6. 객체 지향 설계 과정
- 객체 지향을 설계하는 과정은 아래와 같다.
    1. 제공해야 할 기능을 찾아 분할하고, 그 기능에 맞는 객체를 구현한다.
        - A. 구현에 필요한 데이터를 객체에 추가한 후 그 데이터를 이용하는 기능을 구현한다.
        - B. 기능은 최대한 캡슐화해서 구현한다.
    2. 객체 간에 어떻게 메시지를 주고받을 지 결정한다.
    3. 과정1과 2를 개발하는 동안 반복한다.
    4. 단, 구현 과정에서 한 클래스에 여러 책임이 섞여 있다면 다른 클래스로 책임을 분리해 관리한다.
- 객체 지향 설계는 모든 경우의 수를 생각할 수 없기 때문에 한 번에 되지 않는 경우가 많으며, 설계와 구현이 반복될 수밖에 없다. 
- 단, 설계할 때 변경되는 부분을 고려한 유연한 구조를 갖도록 노력해야 한다.

---

**[출처 및 참고사이트]**
- 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴
- https://ko.wikipedia.org/wiki/%EC%A0%88%EC%B0%A8%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
- http://www.incodom.kr/%EC%A0%88%EC%B0%A8_%EC%A7%80%ED%96%A5
- http://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5
- https://m.blog.naver.com/atalanta16/220249264429
- https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)
- https://panonit.com/blog/overview-message-passing-object-oriented-programming
- https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99
- https://mangkyu.tistory.com/147
- https://www.kernelpanic.kr/12?category=874323
- https://velog.io/@hamdoe/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-5.-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
- https://mongsil-jeong.tistory.com/22