# ch2 객체지향

## < 절차지향? >
- 프로시저로 프로그램을 구성하는 기법
- 절차적 프로그래밍이란 단순히 순차적인 명령 수행이 아니라 루틴, 서브루틴, 메소드, 함수 등(이를 통틀어 프로시저라고 한다.)을 이용한 프로그래밍 패러다임을 뜻한다. 명령형 프로그래밍의 일종이다
- '절차적 프로그래밍'이라는 한국어 번역은 오해의 여지가 크다. Procedural Programming에서 Procedural를 '절차적'으로 번역해버려서 마치 절차적으로 실행하는 것이 중점이 되는 것처럼 보이기 때문이다. 그런데 절차적이지 않은 프로그래밍이란 건 애초에 존재하지 않는다. Procedural의 Procedure는 '절차'라는 의미가 아니라 '프로시저'의 의미이다. 이 패러다임에서는 프로시저 콜, 즉 함수 호출을 통해서 추상화와 재사용성을 얻어내는 것이 본질이기 때문이다. 그러나 이미 교과서에 절차적 프로그래밍이라고 줄기차게 쓰여져 있어서 굳어져버렸기 때문에 어쩔 수 없이 이 번역명이 사용되고 있다.
<br>

- 객체지향 프로그래밍과 비교해서 마치 절차적 프로그래밍이 객체지향의 반대이며 심지어 '절차지향'으로 알고 있는 사람들도 있다. 절차지향이라는 용어는 잘못된 표현이며 절차적 프로그래밍이 맞다. 절차지향으로 부르는 사람이 없는 것은 아니지만 대부분은 절차적 프로그래밍이라는 용어를 사용한다.
- 객체지향이 절차적 프로그래밍의 반대 의미처럼 사용되기도 하는데 사실 객체지향의 반대 개념은 절차적 프로그래밍이 아니다. 절차적 프로그래밍의 관점이 프로시저에서 객체로 확장된 것에 가깝기에 일치한다고 볼 수는 없어도 서로 공유하는 부분이 차이보다 더 많다. 애당초 둘다 명령형 프로그래밍의 하위개념이다. 그래서 보통 제대로 된 서적에서 객체지향과 비교할 때는 "객체지향과 일반적인 절차적 프로그래밍(쉽게말해서 객체를 사용하지 않는)"이라는 단서를 붙힌다.
- 현대 프로그래밍 언어에서의 프로시저와 함수의 구분은 없어진 것이나 다름없기에 함수형 프로그래밍과 절차적 프로그래밍이 동등한 것이냐는 이야기가 있다. 그러나 함수형 프로그래밍의 관점은 순수함수와 일등객체인 함수에 관심이 있는 것이고 절차적 프로그래밍은 함수(그리고 이를 관리하는 모듈)에 의한 재사용성에 초점을 둔 것이기에 두 개념은 차이가 있다.

- #### < 프로시저? >
  + 프로그래밍에서, 프로시저는 루틴이나, 서브루틴 및 함수와 같은 뜻이다. 하나의 프로시저는 특정 작업을 수행하기 위한 프로그램의 일부이다.
<br>

## < 문제점 >
- 데이터와 그 데이터를 사용하는 프로시저를 작성하는 것은 자연스러운 과정으로 최초에 절차 지향적으로 코드를 구현하는 것은 쉽다
- 하지만, 프로그램 규모가 커져서 데이터 종류가 증가하고 이를 사용하는 프로시저가 증가하게 되면 다음과 같은 문제가 발생하게 된다
  + 데이터 타입이나 의미를 변경해야 할 때, 함께 수정해야 하는 프로시저가 증가한다
  + 같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생한다
- 새로운 요구 사항이 생겨서 프로그램의 한 곳을 수정학 되면, 다른 곳에서 문제가 발생하고, 다시 그 곳을 수정하면 또 다른 곳에서 문제가 발생하는 악순환이 발생할 수 있다
- 이는 코드의 수정을 어렵게 만들며, 새로운 기능을 추가하는데 많은 구현 시간(즉, 개발비용)을 투입하게 만든다객체지향은

***
<br>

## < 객체지향? >
- 객체 지향은 데이터 및 데이터와 관련된 프로시저를 객체(object)라고 불리는 단위로 묶는다
- 객체는 프로시저를  실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모여 프로그램을 구성한다
- 각각의 객체는 자신만의 데이터와 프로시저를 가지며 프로시저는 자신이 속한 객체의 데이터에만 접근할 수 있고, 다른 객체에 속한 데이터에는 접근할 수 없다
<br>

- 객체 지향적으로 만든 코드에서는 객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되고 다른 객체에 영향을 주지 않기 때문에, 요구 사항의 변화가 발생하는 경우 절차 지향 방식보다 프로그램을 더 쉽게 변경할 수 있는 장점을 가진다
<br>

## < 절차지향 vs 객체지향 >
![image](https://user-images.githubusercontent.com/69443895/151668232-bfb1e041-a9e5-4162-8db1-a3972fa2f627.png)

- 절차지향은 데이터를 중심으로 함수를 구현
- 객체지향은 기능을 중심으로 메서드 구현
***
<br>

## < 객체? >
### :one: 객체의 핵심은 기능을 제공하는 것
- 객체 지향의 기본은 객체다
- 객체가 내부적으로 데이터를 어떤 타입으로 보관하며 그 데이터를 어떻게 처리하는지 보다 객체가 어떤 기능을 제공하냐가 중요하다
<br>

### :two: 인터페이스와 클래스
- 객체가 제공하는 기능을 오퍼레이션(operation)이라고 부른다
- 오퍼레이션은 < 1. 기능 식별 이름  2. 파라미터 및 파라미터 타입  3. 기능 실행 결과 값 > 세 가지로 구성된다
- 객체가 제공하는 모든 오퍼레이션 집합을 객체의 인터페이스(interface) 라고 부르며 서로 다른 인터페이서를 구분할 때 사용되는 명칭이 바로 타입이다
- 지금 설명하고 있는 인터페이스는 java, c# 언어에 포함되는 인터페이스가 아니라, 객체 지향에서 오퍼레이션 집합을 표현할 때 사용되는 용어이다
- 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이라고 생각하면 된다
<br>

- 인터페이스는 객체가 제공하는 기능에 대한 명세서일 뿐, 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함하고 있지 않다
- 실제 객체의 구현을 정의하는 것은 클래스(class)이다
<br>

### :three: 메시지
- 오퍼레이션의 실행을 요청하는 것을 '메시지를 보낸다' 라고 표현한다
- java와 같은 언어에서는 메서드를 호출하는 것이 메시지를 보내는 과정에 해당된다

```java
FileInputStream is = new FileInputStream(fileName);
byte[] data = new byte[512];
int readByte = is.read(data);
```
- 위 코드에서 is 변수는 FileInputStream 타입의 객체를 참조한다
- is.read(data) -> is가 참조한느 객체에 read() 오퍼레이션을 실행해 달라는 메시지를 전송한다고 생각하면 된다
***
<br>

## < 객체의 책임과 크기 >
- 객체는 객체가 제공하는 기능으로 정의된다
- 이는 다시 말하면 객체마다 자신만의 책임이 있다는 의미를 가진다
- 한 객체가 가지는 책임을 정의한 것이 바로 타입/인터페이스 라고 생각하면 된다
- 객체 지향적 설계에서 가장 어려우면서 중요한 것이 바로 객체마다 기능을 할당하는 과정이다

<br>
- 객체가 갖는 책임의 크기가 작을수록 좋다
- 책임이 작다 = 객체가 제공하는 기능의 개수가 적다
- 객체의 책임이 커질수록 절차 지향적으로 구조가 변질된다 -> 기능 변경의 어려움 문제가 발생

- #### < 단일 책임 원칙 >
  + 객체는 단 한개의 책임만을 가져야 한다는 원칙
  + 책임의 크기가 작을수록 변화 대응에 유리
***
<br>

## < 의존 >
- 객체 지향적으로 프로그램을 구현하다 보면, 다른 객체가 제공하는 기능을 이용해서 자신의 기능을 완성하는 객체가 출현하게 된다
- 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 의존한다고 표현한다
<br>

```java
public void process(ByteEncryptor encryptor){
  // 메서드 내부에서 encryptor 사용
}
```
- process() 메서드가 ByteEncryptor에 의존한다고 볼 수 있다
<br>

- 객체를 생성하든 메서드를 호출하든 또는 파라미터로 전달받든 다른 타입에 의존을 한다는 것은 의존하는 타입에 변경이 발생할 때 나도 함께 변경될 가능성이 높다는 것을 뜻한다
- 의존이 순환해서 발생하는 경우 이를 해소하는 방법을 찾아야 한다
- 순환 의존이 발생하지 않도록 하는 원칙 중의 하나로 의존 역전 원칙(DIP)이 있다 -> ch5 에서 공부
***
<br>

## < 캡슐화 >
- 객체 지향은 기본적으로 캡슐화를 통해서 한 곳의 변화가 다른 곳에 미치는 영향을 최소화한다
- 캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다
- 이를 통해 내부의 기능 구현이 변경되더라도 그 기능을 사용하는 코드는 영향을 받지 않도록 만들어준다
<br>

- 데이터를 중심으로 프로그래밍을 하게 되면 데이터를 직접적으로 사용하는 코드는 데이터의 변화에 직접적인 영향을 받기 때문에, 요구 사항의 변화로 인해 모든 데이터의 구조 혹은 쓰임새가 변경된다면 이 데이터를 사용하는 코드들도 연쇄적으로 수정해 주어야 한다
- 따라서 객체 내부에서 메서드를 정의하고 기능을 구현해두면 외부에서는 데이터의 처리 방식을 몰라도 해당 메서드를 가져다 사용만 하면 된다
- 요구 사항 변경 시 해당 메서드만 수정하면 되고, 이를 사용하는 부분은 수정할 필요가 없다

### < 캡슐화를 위한 규칙 >
- **Tell, Don't Ask**
  + 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라는 규칙
  + 절차 지향 방식의 경우 데이터를 가져와서 직접 데이터의 조작을 통해 기능 구현
  + 데이터를 직접 가져오는 것이 아닌, 기능 실행을 요청하는 방식으로 코드를 작성하다 보면 자연스럽게 해당 기능을 어떻게 구현했는지 여부가 감춰진다
- **데미테르의 법칙**
  + 데미테르의 법칙은 'Tell, Don't Ask' 규칙을 따를 수 있도록 만들어 주는 또 다른 규칙이다
  + 데미테르의 법칙은 다음과 같이 간단한 규칙으로 구성된다
    - 메서드에서 생성한 객체의 메서드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출
```java
public void processSome(Member member){
  if(member.getDate().getTime < 100){
    // 데미테르 법칙 위반
  }
}
```
- 위 경우 meber의 getDate 메서드를 호출하고 리턴받은 Date 객체의 getTime 메서드를 호출하여 데미테르 법칙을 위반했다
- member 객체에 대한 한 번의 메서드 호출로 변경을 해줘야 한다
***
<br>

## < 객체 지향 설계 과정 >
- 객체 지향 설계는 다음 작업을 반복하는 과정이라 볼 수 있다
  + 1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에 할당한다
    - 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다
    - 기능은 최대한 캡슐화해서 구현한다
  + 2. 객체 간에 어떻게 메시지를 주고받을 지 결정한다
  + 과정1, 과정2를 개발하는 동안 지속적으로 반복한다

- 초기에 완벽한 객체지향적 설계를 할 수는 없는 것 같다
- 책에서 설명한 것처럼 구현을 진행하면서 특정 클래스에 여러 책임이 섞여 있다는 것을 발견하게 되고 이 경우 새로운 객체를 만드는 과정을 통해 책임을 분리하면 될 것 같다

***
<br>

#### < 추가 공부 >
- 인터페이스 vs 추상클래스 (https://velog.io/@k906506/Kotlin-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4-VS-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4)
- 의존성 주입이 필요한 이유 (https://velog.io/@wlsdud2194/what-is-di)
