## 객체 지향

### [1]. 절차 지향과 객체 지향

#### 절차 지향

-  데이터를 조작하는 코드를 별도로 분리해 함수나 프로시저와 같은 형태로 개발한다.

   각 프로시저들이 데이터를 조작하는 방식으로 코드를 작성한다.

   프로시저로 프로그램을 구성하는 기법을 절차 지향 프로그래밍이다.

- `데이터를 중심` 으로 한 프로시저로 구성된다.

  데이터 타입이나 의미를 변경할 때, 함께 수정해야하는 프로시저가 증가한다.
 
  같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생한다.


#### 객체 지향

- 절차 지향과 다르게 데이터 및 데이터와 관련된 프로시저를 `객체` 라 부른다.

  데이터와 프로시저를 함께 갖는 객체들의 네트워크라 생각하면 된다.

- 객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되며, 다른 객체에 영향을 주지 않는다.

  객체 지향적으로 설계하는데 많은 시간이 들어가지면 추후 상대적으로 쉬운 수정이 가능한 유연함이 있다.

---

### [2]. 객체

#### 객체의 핵심은 기능을 제공하는 것

- 객체 지향의 기본 베이스는 `객체` 이다.

- 객체를 정의할 때 사용되는 것은 객체가 제공해야 할 기능이며, 객체가 내부적으로 어떤 데이터를 갖고 있는지로 정의되지 않는다.

  예로, 소리 크기 제어 객체가 있다면, 제공해야 할 기능은 소리 크기 증가, 소리 크기 감소, 음소거가 존재한다.

  내부적으로 소리 크기를 어떤 데이터 타입을 보관하는지는 중요하지가 않다. 즉, 소리 크기 증가, 감소, 음소거 라는 기능을 제공하는 것이 중요하다.


#### 인터페이스와 클래스

- 객체가 제공하는 기능을 `오퍼레이션(operation)` 이라고 부르고, 오페레이션으로 정의된다.

  오퍼레이션은 `기능 식별 이름` / `파라미터 및 파라미터 타입` / `기능 실행 결과 값` 으로 세 개로 구성되며, `시그니처(Signature)` 라 부른다.

- 모든 오퍼레이션의 집합을 객체의 인터페이스라 부르며, 서로 다른 인터페이스를 구분할 때 사용되는 명칭이 바로 타입이다.

  여기서 말하는 인터페이스는 자바에서 키워드로 사용되는 인터페이스가 아니다.

  객체를 사용하기 위한 일종의 명세서 혹은 규칙이다.

- 인터페이스는 말그대로 명세서일 뿐이다. 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함하고 있지 않는다.

  객체의 구현을 정의하는 것은 `클래스(class)` 이다.

  클래스에는 오퍼레이션을 구현하는데 필요한 데이터 및 오퍼레이션의 구현이 포함된다.

  ![image](https://user-images.githubusercontent.com/66770613/151643370-2c0e9ecc-9adf-4fcc-954e-3ea735ab4347.png)


#### 메시지

- 객체 지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 만든다.

- 예로 들어, `파일에서 데이터를 읽어오는 객체` / `데이터를 암호화 해주는 객체` / `파일에 데이터를 쓰는 객체` 가 존재한다.

  특정 파일에서 데이터를 읽어와 암호화 한 뒤에 다른 파일에 쓰는 프로그램은 세 개의 객체로 구성된다.

  서로 객체는 다른 객체에 메시지를 보낼 수 있다.

  파일 읽기 객체가 제공하는 인터페이스가 제공하는 오퍼레이션을 보게 되면,

  - 오퍼레이션 이름: read
  - 파라미터: 없음
  - 리턴 타입: byte 배열

- 암호화 처리 객체는 파일 읽기 객체에게 read 오퍼레이션을 실행해달라고 메시지를 요청 전달한다.

  파일 읽기 객체는 해당 메시지에 해당하는 기능을 실행한 뒤 응답을 전달해 줄 수 있다.

  ```java
  FileInputStream is = new FileInputStream(fileName);
  byte[] data = new byte[512];
  int readBytes = is.read(data);
  /**
   * is변수는 FileInputStream 타입의 객체를 참조하는데, is.read(data)코드는 is가
   * 참조하는 객체에 read() 오퍼레이션을 실행해 달라는 메시지를 전송한다.
   */ 
  ```

---

### [3]. 객체의 책임과 크기

- 객체는 객체가 제공하는 기능으로 정의된다.

  즉, 객체마다 자신만의 `책임` 이 있다는 것을 의미한다.

- 파일 읽기 객체는 파일에서 데이터를 읽어와 제공하는 책임

  암호화 처리 객체는 제공받은 데이터를 암호화해서 다른 파일에 보내는 책임

  파일 쓰기 객체는 파일에 데이터를 쓰는 책임으로 알맞은 책임을 갖는다.

- 한 객체가 갖는 책임을 정의하는 것이 바로 타입/인터페이스이다.

  객체가 갖는 책임을 결정하는 것은 객체 지향 설계의 출발점이다.

- 객체의 책임은 바로 결정되는 것이 아니라, 필요한 기능 목록을 정리해야 한다. (머리로, 종이로, 테스크 코드를 만들어서 시행착오가 필요하다.)

- 책임 분배에 따라 객체의 구성이 달라진다.

- 가장 중요한 것이 바로 객체마다 기능을 할당하는 과정이다. 할당하는 과정에서 다양한 조합이 생기는데 알맞은 구성을 찾는 것이 가장 어려운 부분이다.

  고려해야 할 부분은 객체가 갖는 책임의 크기는 작을수록 좋은 것이고 객체가 제공하는 기능의 개수가 적다는 걸 의미한다.

  한 객체에 모든 기능을 포함하고 있다고 하면, 절차 지향 방식으로 다를 것이 없다.


- 그래서, 단일 책임 원칙(SRP)로 객체는 단 한 개의 책임만을 가져야 한다.

  단일 책임 원칙을 하게 되면, 기능 수정 시, 자연스럽게 변경해야 할 부분이 한 곳으로 집중된다.


---

### [4]. 의존

- 객체 지향 구현 시, 다른 객체가 제공하는 기능을 이용해 자신의 기능을 완성하는 경우가 발생한다.

  한 객체가 다른 객체를 이용한다는 것은, 실제 구현에서 한 객체의 코드에서 다른 객체를 생성하거나 메소드를 호출한다는 것이다.

- 한 객체가 다른 객체를 생성하거나 메서드를 호출 할 때, `의존(dependency)` 한다고 말한다.

  객체 생성 및 메서드 호출 뿐 아니라 파라미터로 전달받는 경우에도 의존한다.

  의존하는 타입에 변경이 발생할 때 나도 함께 변경될 가능성이 높다는 것을 의미하는 것이다.

- 의존의 영향은 꼬리에 꼬리를 문 것처럼 전파되는 특징을 가지고 있다.

  C클래스가 B클래스를 의존하고 B클래스가 A클래스를 의존하게 되면, 한 쪽에서 변경이 일어나면 영향을 줄 가능성이 높아진다.

  더 불어 자기 자신에게 돌아오는 순환 의존이 일어날 수도 있다.

- 순환 의존이 발생할 경우 해소하기 위한 방법으로 `의존 역전 원칙(DIP)` 이 존재한다.

  내가 변경되면 나에게 의존하고 있는 코드에 영향을 주게 되며,

  나의 요구가 변경되면 내가 의존하고 있는 타입에 영향을 줄 수 있다.


---

### [5]. 캡슐화

- 객체 지향의 장점은 한 곳의 구현 변경이 다른 곳에 영향을 가지 않는 것이다.

  수정을 원할하게 하기 위해서 객체지향을 이용하는 경우가 많다.

  객체 지향에서 캡슐화를 통해 한 곳의 변화가 다른 곳에 미치는 영향을 최소화한다.

- `캡슐화` 는 객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것이다.

  단순하게 소리 제어 객체에서 소리 음소거를 어떻게 하는지에 대한 내부 구현이 알 필요가 없이 음소거 기능을 이용하겠다는 요청만 하면 된다.

  
- Tell Don't Ask
   
  - 나는 너의 기능만 필요하니깐 실행만 시켜줘!!

- 데미테르 법칙
   
  - 메서드에서 생성한 객체의 메서드만 호출
  - 파라미터로 받은 객체의 메서드만 호출
  - 필드로 참조하는 객체의 메서드만 호출
  - 연속된 get 메서드를 호출하는 것을 피한다.

   ```
   String name = food.getOrange().getNmae()
   ```


---

### [6]. 객체지향 설계 과정


- 필요한 기능들을 정리하고 최대한 책임을 세분화하여 , 그 기능들을 각 객체에 할당한다.

- 기능 구현에 필요한 데이터들을 추가하고, 기능을 최대한 캡슐화 하여 클래스를 구현한다.

- 객체간 어떤 메시지를 요구할지 생각하기.








  
