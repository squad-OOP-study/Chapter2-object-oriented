## 1. 절차 지향 프로그래밍

### 절차지향 프로그래밍의 정의

- 절차지향 프로그래밍이란 프로그램을 재상용 가능한 함수단위(프로시저)로 나눈 구조의 프로그래밍 패러다임이다.
- 절차지향의 '절차' 의 의미는 Procedual 즉 함수를 의미한다.

### 절차 지향의 단점

- 다수의 함수들이 데이터를 공유하며 데이터 중심으로 구현하게 됨
- 데이터 타입이나 의미를 변경해야할 때 , 함께 수정해야하는 프로지시저(함수)가 증가한다.
- 같은 데이트를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생한다.

## 2. 객체 지향 프로그래밍

### 객체지향 프로그래밍의 정의

- 객체(데이터 + 메서드) 단위로 코딩을 함
- 객체는 그 기능(오퍼레이션)으로서 정의됨(내부 데이터와 내부 메서드들이 아닌)
- 오퍼레이션을 사용하기 위해서는 시그니처(이름 , 인자와 인자 타입 , 반환값(타입))를 알아야한다.

### 객체의 책임과 크기

- 객체는 그 기능들로서 정의되고 이에 따라 객체 각각은 책임을 갖게된다.
- 객체의 책임은 작으면 작을 수 록 좋다. 더 나아가 SOLID 정신의 단일책임의 원리와도 일맥상통하다.
- 책임을 세분화 할 수록 유지보수에 유리해 진다.

### 의존

- 객체가 객체 내부에서 다른 객체를 생성하거나 파라미터라 받아서 사용하는 것을 의미함
    - A 객체 내부에서 B 객체를 사용한다면 A가 B에 의존하고 있다고 봄.

- 의존 관계속 한 개체의 변경은 의존 관계에 따라 전의되어 다른 변경을 야기한다.
    - A 가 B 에 의존할때 B의 변화는 A의 변경을 야기한다.
    - A 가 B 에 의존할때 A의 변화도 B에 변경을 야기할 수 있다.

- 순환의존 관계에서의 자신의 변경은 관계에 따라 전의 되어 다시 자신의 변경을 야기 시킬 수 있기 때문에 적극적 해소가 필요하다.
    - 순환 의존이란 A 가 B 에 B 가 C에 그리고 C 가 다시에 A 에 의존할 경우 A를 의미한다.

### 캡슐화

- 캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다.
- 캡슐화를 통해 캡슐 내부의 변경이 외부의 변경을 가하지 않게 하여 유지보수 쉽게한다.
    - 기능의 캡슐화를 잘 지킨다면 내부의 변경으로부터 그 기능을 사용하는 외부의 변경을 막을 수 있다.

### 캡슐화의 방법

#### 방법 1 : Tell Don't Ask

- 데이터를 묻지 않고 실행해달라는 규칙이다.
- 데이터가 아닌 기능을 요청할때 그 기능을 어떻게 구현했는지 여부는 자연스럽게 캡슐화되어 감춰지게 된다.
- ex] if (member.getExpireDate() != null)  -> if(member.isExpired())

#### 방법 2 : 데미테르 법칙

1. 메서드에서 생성한 객체의 메서드만 호출
2. 파라미터로 받은 객체의 메서드만 호출
3. 필드로 참조하는 객체의 메서드만 호출

- 데미테르 법칙의 핵심은 캡슐 내부로 침투함을 방지함으로써 캡슐화를 이루는 것이다.
- [ 위반 1 ] 연속된 get 메서드를 호출하는 것을 피한다.
- [ 위반 2 ]임시 변수의 할당된 객체의 get을 호출하는 코드가 많은 상황을 피한다. : [ 위반 1]의 연장선상이다.

```
// 위반 2 예시
A a = someObject.getA();
B b = a.getB();
value = b.getValue();
```

### 객체지향 설계 과정

객체 지향 설계는 결국 위의 내용의 종합이다.

1. 필요한 기능들을 정리하고 최대한 책임을 세분화하여 , 그 기능들을 각 객체에 할당한다.
2. 기능 구현에 필요한 데이터들을 추가한다.
3. 기능을 최대한 캡슐화 하여 클래스를 구현한다.
    - Tell Don't Ask 와 디미테르 법칙 적용
4. 객체간 어떻게 통신할지 결정하다.
    - 통신(메세지) : 객체간 특정 기능을 요청하거나 제공해주는 방식
5. 위의 과정을 개발하는 동안 지속적으로 반복한다.