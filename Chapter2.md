# Chapter2

## 1 절차지향/ 객체지향
### 절차지향
* 특징 
	* 최소단위를 프로시저로 보는 페러다임
	* 하나의 큰 기능을 처리하기 위해 작은 단위의 프로시저들로 나누어 처리하는 Top-Down 방식
	* 특정 기능을 수행하려면 해당 프로시저를 직접 호출
	* 절차지향이라 해서 반드시 순차지향적인 것은 아니다 
	* 프로시저끼리 서로 유기적으로 연결되어 있어, 여러 프로시저가 동일한 데이터를 공유한다  

* 장점
	* 비교적 유지,보수가 덜 중요한 개인 프로젝트에 적합할 수 있다 
	* 객체지향 프로그래밍에 비해 빠르다 

*단점
	*  데이터의 수정(타입 변경, 의미 변경)이 요구될 때 여러 프로시저에서 수정이 요구된다	= 유지, 보수가 어렵다 
	*  실행 순서(프로시저 호출 순서)가 정해져 있음으로,  변경될 경우 동일한 결과를 보장하지 않는다
	*  디버깅, 분석이 어렵다 

### 객체지향
* 특징
	* 최소단위를 객체로 보는 페러다임
	* 작은 문제를 해결하는 객체를 생성해 큰문제를 해결하는 Bottom-Up 방식.
	* 객체는 자신만의 데이터와 프로시저를 가진다
	* 객체는 다른 객체에 기능을 제공하기 위해 프로시저를 사용한다. 이 때 프로시저는 다른 객체의 데이터에는 접근 불가능하다. 
	* 객체는 객체가 제공하는 기능 (=operation)으로 정의 된다 

* 장점
	* 상속을 통한 코드의 재사용성
	* 객체끼리 데이터를 공유하지 않기 때문에,  데이터의 수정(타입 변경, 의미 변경)이 요구될 때 해당 데이터를 가지는 객체만 수정되면 된다 =>캡슐화 = 유지, 보수가 용이하다
	* 상속, 다형성을 통한 프로그램이 확장이 비교적 용이함
	* 기능이 객체 별로 분리되어 있기 때문에 디버깅, 분석이 비교적 용이함 

* 단점
	* 재사용성만을 위해 상속을 사용할 경우 혼란 발생의 가능성 존재  -> 다형성 구현을 위해 상속을  사용하는 것이 바람직하다
	* 설계에 많은 시간이 요구됨 
	* 절자지향에 비해 비교적 느리다

### 정리
* 객체지향의 반대가 절차지향도 아니며, 절차지향의 반대가 객체지향도 아니다
* 객체지향은 기능(operation) 중심,   절차지향은 데이터 중심의  패러다임 


## 2 객체지향의 주요 특징 
### 2-1 인터페이스, 클래스
#### 인터페이스
* 객체가 제공하는 모든 오퍼레이션의 집합  
* 객체를 사용하기 위한 일종의 명세
* 실제 기능을 포함하고 있지 않다
* 자바나 C#에서 제공하는 인터페이스 타입과 개념적인 인터페이스는 다르다. 

#### 클래스 
* 인터페이스에 명시된 오퍼레이션을 실질적으로 구현함
* 객체를 생성하기위한 청사진
* 오퍼레이션을 구현하기 위한 속성 (property), 메소드(method)를 포함함
* 클래스를 이용해 메모리에 객체 생성이 가능하며, 이렇게 생성된 객체를  인스턴스라 함


### 2-2 메시지
* 객체지향은 기능을 제공하는 여러 객체가 합쳐져 완성된 프로그램을 구성한다
* 프로그램 구성시  각 객체에 기능을 요구(request) 할 필요가 있고, 이것을 message라고 한다
* 각 객체는 기능을 요청받으면, 해당 기능을 실행한뒤, 응답을 전달한다. 


### 2-3 객체의 책임과 크기
* 객체의 책임은 객체가 제공하는 기능에 의해 결정됨
* 책임을 어떻게 분배할 것인가  == 기능을 어떻게 분배 할 것인가  ==  객체 지향 설계의 시작
* 프로그램에 필요한 기능을 정리 -> 이 기능들을 어떻게 분배하느냐에 따라 객체의 구성이 달라진다. 
* 어떻게 분배하느냐는 모든 상황에 대한 정확한 정답은 존재하지 않으며, 객체지향 설계의 어려움의 원인이다. 
* 확실한 규칙은 가능한 객체에 부여하는 책임을 최소화하라 == 객체가 제공하는 기능의 개수가 작을수록 좋다
=> 객체가 제공하는 기능이 많아지면,  한 객체에 많은 데이터와 메소드가 담기게 되고, 공유된다 => 절차지향의 단점인 유지,보수의 어려움이 생길 수 있다. 
=> 단일 책임 원칙 (SRP: Single Responsibility Principle) == 객체는 한 개의 책임만을 가져야 한다 

### 2-4 의존
  
	
