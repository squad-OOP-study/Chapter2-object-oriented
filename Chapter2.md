# Chapter2

## 1 절차지향/ 객체지향
### 절차지향
* 특징 
	* 최소단위를 프로시저로 보는 페러다임
	* 하나의 큰 기능을 처리하기 위해 작은 단위의 프로시저들로 나누어 처리하는 Top-Down 방식
	* 특정 기능을 수행하려면 해당 프로시저를 직접 호출
	* 절차지향이라 해서 반드시 순차지향적인 것은 아니다 
	* 프로시저끼리 서로 유기적으로 연결되어 있어, 여러 프로시저가 동일한 데이터를 공유한다  

* 장점
	* 비교적 유지,보수가 덜 중요한 개인 프로젝트에 적합할 수 있다 
	* 객체지향 프로그래밍에 비해 빠르다 

*단점
	*  데이터의 수정(타입 변경, 의미 변경)이 요구될 때 여러 프로시저에서 수정이 요구된다	= 유지, 보수가 어렵다 
	*  실행 순서(프로시저 호출 순서)가 정해져 있음으로,  변경될 경우 동일한 결과를 보장하지 않는다
	*  디버깅, 분석이 어렵다 

### 객체지향
* 특징
	* 최소단위를 객체로 보는 페러다임
	* 작은 문제를 해결하는 객체를 생성해 큰문제를 해결하는 Bottom-Up 방식.
	* 객체는 자신만의 데이터와 프로시저를 가진다
	* 객체는 다른 객체에 기능을 제공하기 위해 프로시저를 사용한다. 이 때 프로시저는 다른 객체의 데이터에는 접근 불가능하다. 
	* 객체는 객체가 제공하는 기능 (=operation)으로 정의 된다 

* 장점
	* 상속을 통한 코드의 재사용성
	* 객체끼리 데이터를 공유하지 않기 때문에,  데이터의 수정(타입 변경, 의미 변경)이 요구될 때 해당 데이터를 가지는 객체만 수정되면 된다 =>캡슐화 = 유지, 보수가 용이하다
	* 상속, 다형성을 통한 프로그램이 확장이 비교적 용이함
	* 기능이 객체 별로 분리되어 있기 때문에 디버깅, 분석이 비교적 용이함 

* 단점
	* 재사용성만을 위해 상속을 사용할 경우 혼란 발생의 가능성 존재  -> 다형성 구현을 위해 상속을  사용하는 것이 바람직하다
	* 설계에 많은 시간이 요구됨 
	* 절자지향에 비해 비교적 느리다

### 정리
* 객체지향의 반대가 절차지향도 아니며, 절차지향의 반대가 객체지향도 아니다
* 객체지향은 기능(operation) 중심,   절차지향은 데이터 중심의  패러다임 


## 2 객체지향의 주요 특징 
### 2-1 인터페이스, 클래스
#### 인터페이스
* 객체가 제공하는 모든 오퍼레이션의 집합  
* 객체를 사용하기 위한 일종의 명세
* 실제 기능을 포함하고 있지 않다
* 자바나 C#에서 제공하는 인터페이스 타입과 개념적인 인터페이스는 다르다. 

#### 클래스 
* 인터페이스에 명시된 오퍼레이션을 실질적으로 구현함
* 객체를 생성하기위한 청사진
* 오퍼레이션을 구현하기 위한 속성 (property), 메소드(method)를 포함함
* 클래스를 이용해 메모리에 객체 생성이 가능하며, 이렇게 생성된 객체를  인스턴스라 함


### 2-2 메시지
* 객체지향은 기능을 제공하는 여러 객체가 합쳐져 완성된 프로그램을 구성한다
* 프로그램 구성시  각 객체에 기능을 요구(request) 할 필요가 있고, 이것을 message라고 한다
* 각 객체는 기능을 요청받으면, 해당 기능을 실행한뒤, 응답을 전달한다. 


### 2-3 객체의 책임과 크기
* 객체의 책임은 객체가 제공하는 기능에 의해 결정됨
* 책임을 어떻게 분배할 것인가  == 기능을 어떻게 분배 할 것인가  ==  객체 지향 설계의 시작
* 프로그램에 필요한 기능을 정리 -> 이 기능들을 어떻게 분배하느냐에 따라 객체의 구성이 달라진다. 
* 어떻게 분배하느냐는 모든 상황에 대한 정확한 정답은 존재하지 않으며, 객체지향 설계의 어려움의 원인이다. 
* 확실한 규칙은 가능한 객체에 부여하는 책임을 최소화하라 == 객체가 제공하는 기능의 개수가 작을수록 좋다
=> 객체가 제공하는 기능이 많아지면,  한 객체에 많은 데이터와 메소드가 담기게 되고, 공유된다 => 절차지향의 단점인 유지,보수의 어려움이 생길 수 있다. 
=> 단일 책임 원칙 (SRP: Single Responsibility Principle) == 객체는 한 개의 책임만을 가져야 한다 

### 2-4 의존
* 객체가 구현에 있어서 다른 객체를 생성하거나 , 다른 객체의 메서드를 호출하는 경우가 있다면 -> 그 객체에 의존한다 라고 본다 
* 다른 객체를 생성하든, 다른 객체의 메서드를 이용하든, 그것을 파라미터로 받든  의존관계가 있다는것은  의존하는 객체에 변화가 일어날 경우, 자신도 변화할 가능성이 높다는 것이다.
* 의존관계에서 한 객체의 변화는 다른 객체의 변화로 전이 될 수 있다.
* 의존관계중 자신을 의존하고 있는 객체의 의존관계를 따라가면 다시 자기자신이 의존하는 관게에 있는 경우를 순화의존 관계(순환참조)라고 한다.  
![image](https://user-images.githubusercontent.com/58967292/151185569-59a533f6-4a9c-406b-8193-bba5e458b855.png)
* 순환의존은 자기자신의 변화가 자시자신의 변화를 야기 시킬 수 있다.

## 2-5 캡슐화
* 객체 지향이 절차 지향에 비해 가지는 좋은 점중 하나는 한 곳의 구현변경이 다른 곳에 변경을 가하지 않도록 해주게 하는 것이다.
* 객체 지향은 캡슐화를 통해 한 곳의 변경이 다른 곳에 영향을 미치는 것을 최소화 한다 .
* 캡슐화는 내부적으로 기능을 어떻게 구현했는지 감추는 것이다. 즉 기능을 사용하는 것만 가능하게 하는 것이다. 
* 캡슐화가 잘 지켜진 객체 지향구조는 내부 변경에 유연성을 가진다. 변경이 일어난다고 해서, 기능이 사용되는 모든 곳을 수정할 필요가 없다. 
* 캡슐화가 잘 지켜진 구조를 짜기 위한 두 가지 규칙이 존재한다
	* Tell, Don't ask  
		+ 데이터를 요청하는 것이 아니라, 기능 실행을 요구하도록 해라 
	* 데미테르의 법칙(디미터의 법칙): 결합도가 낮은 설계를 위한 원칙
		+ 메서드에서만 생성한 객체의 메서드만 호출 
		+ 파라미터로 받은 객체의 메서드만 호출
		+ 필드로 참조하는 객체의 메서드만 호출 
		+ 메서드 호출로 객체를 리턴받고 리턴받은 객체의 메서드를 호출하면 X
		+ 위반되는 대표적인 케이스 : 연속된 get method 호출 or  임시 변수의 get 호출이 많음		

## 3 객체지향 설계과정 (정리)
1. 프로그램을 구현하는데 필요한 기능들을 정리하고, 세분화한다
2. 정리,세분화된 기능들을 알맞은 객체에 할당한다. 각 객체가 가지는 책임을 최소화 하도록 한다. (SRP 원칙 기억)
3. 기능을 구현하는데 필요한 데이터를 객체에 추가. ( 데이터를 추가하고 데이터를 이용해 기능을 구현해도 무관)
4. 기능은 가능한한 캡슐화 원칙을 지키면서 구현  (Tell Don't ask,  데미테르 법칙 기억)
5. 객체 간의 어떻게 메시지를 주고 받을지 결정 , 이 때 순환의존 관계가 발생하지 않도록 주의
6. 1~5 과정을 프로그램 구현 도중 계속 반복해서 진행 
